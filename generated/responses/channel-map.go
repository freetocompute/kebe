// Code generated by schema-generate. DO NOT EDIT.

package responses

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// Attributes
type Attributes struct {
}

// ChannelMapItems
type ChannelMapItems struct {
	Architecture string `json:"architecture"`

	// The channel name, including "latest/" for the latest track.
	Channel string `json:"channel"`

	// The date when this release expires, in RFC 3339 format. If null, the release does not expire.
	ExpirationDate interface{}  `json:"expiration-date"`
	Progressive    *Progressive `json:"progressive"`
	Revision       int          `json:"revision"`

	// The date when this release was made, in RFC 3339 format.
	When string `json:"when"`
}

// ChannelsItems A list of channels and their metadata for the requested snap.
type ChannelsItems struct {

	// The branch name for this channel, can be null.
	Branch interface{} `json:"branch"`

	// The name of the channel that this channel would fall back to if there were no releases in it. If null, this channel has no fallback channel.
	Fallback interface{} `json:"fallback"`

	// The channel name, including "latest/" for the latest track.
	Name string `json:"name"`

	// The risk name for this channel.
	Risk string `json:"risk"`

	// The track name for this channel.
	Track string `json:"track"`
}

// Epoch
type Epoch struct {
	Read  interface{} `json:"read"`
	Write interface{} `json:"write"`
}

// Progressive
type Progressive struct {
	CurrentPercentage interface{} `json:"current-percentage"`
	Paused            interface{} `json:"paused"`
	Percentage        interface{} `json:"percentage"`
}

// Publisher Publisher details for this snap.
type Publisher struct {
	DisplayName string `json:"display-name,omitempty"`

	// The Account ID for this user.
	Id       string `json:"id,omitempty"`
	Username string `json:"username,omitempty"`
}

// RevisionsItems
type RevisionsItems struct {
	Architectures []string    `json:"architectures"`
	Attributes    *Attributes `json:"attributes,omitempty"`
	Base          string      `json:"base,omitempty"`
	BuildUrl      interface{} `json:"build-url,omitempty"`
	Confinement   string      `json:"confinement,omitempty"`
	CreatedAt     string      `json:"created-at,omitempty"`
	Epoch         *Epoch      `json:"epoch,omitempty"`
	Grade         string      `json:"grade,omitempty"`
	Revision      int         `json:"revision"`
	Sha3384       string      `json:"sha3-384,omitempty"`
	Size          int         `json:"size,omitempty"`
	Version       string      `json:"version"`
}

// Root
type Root struct {
	ChannelMap []*ChannelMapItems `json:"channel-map"`
	Revisions  []*RevisionsItems  `json:"revisions"`

	// Metadata about the requested snap.
	Snap *Snap `json:"snap"`
}

// Snap Metadata about the requested snap.
type Snap struct {

	// The list of most relevant channels for this snap. Branches are only included if there is a release for it.
	Channels []*ChannelsItems `json:"channels"`

	// The default track name for this snap. If no default track is set, this value is null.
	DefaultTrack interface{} `json:"default-track,omitempty"`

	// The snap ID for this snap package.
	Id string `json:"id,omitempty"`

	// The snap package name.
	Name string `json:"name"`

	// Whether this snap is private or not.
	Private bool `json:"private,omitempty"`

	// Publisher details for this snap.
	Publisher *Publisher `json:"publisher,omitempty"`

	// The snap title.
	Title string `json:"title,omitempty"`

	// An ordered list of most relevant tracks for this snap.
	Tracks []*TracksItems `json:"tracks,omitempty"`
}

// TracksItems An ordered list of tracks and their metadata for this snap.
type TracksItems struct {

	// The track creation date, in ISO 8601 format. For the "latest" track, the creation date is null.
	CreationDate interface{} `json:"creation-date"`

	// The track name.
	Name string `json:"name"`

	// The status of this track.
	Status string `json:"status,omitempty"`

	// A Python regex to validate the versions being released to this track. If null, no validation is enforced.
	VersionPattern interface{} `json:"version-pattern,omitempty"`
}

func (strct *ChannelMapItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Architecture" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "architecture" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"architecture\": ")
	if tmp, err := json.Marshal(strct.Architecture); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Channel" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "channel" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"channel\": ")
	if tmp, err := json.Marshal(strct.Channel); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "ExpirationDate" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "expiration-date" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"expiration-date\": ")
	if tmp, err := json.Marshal(strct.ExpirationDate); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Progressive" field is required
	if strct.Progressive == nil {
		return nil, errors.New("progressive is a required field")
	}
	// Marshal the "progressive" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"progressive\": ")
	if tmp, err := json.Marshal(strct.Progressive); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Revision" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "revision" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"revision\": ")
	if tmp, err := json.Marshal(strct.Revision); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "when" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"when\": ")
	if tmp, err := json.Marshal(strct.When); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ChannelMapItems) UnmarshalJSON(b []byte) error {
	architectureReceived := false
	channelReceived := false
	expirationDateReceived := false
	progressiveReceived := false
	revisionReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "architecture":
			if err := json.Unmarshal([]byte(v), &strct.Architecture); err != nil {
				return err
			}
			architectureReceived = true
		case "channel":
			if err := json.Unmarshal([]byte(v), &strct.Channel); err != nil {
				return err
			}
			channelReceived = true
		case "expiration-date":
			if err := json.Unmarshal([]byte(v), &strct.ExpirationDate); err != nil {
				return err
			}
			expirationDateReceived = true
		case "progressive":
			if err := json.Unmarshal([]byte(v), &strct.Progressive); err != nil {
				return err
			}
			progressiveReceived = true
		case "revision":
			if err := json.Unmarshal([]byte(v), &strct.Revision); err != nil {
				return err
			}
			revisionReceived = true
		case "when":
			if err := json.Unmarshal([]byte(v), &strct.When); err != nil {
				return err
			}
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	// check if architecture (a required property) was received
	if !architectureReceived {
		return errors.New("\"architecture\" is required but was not present")
	}
	// check if channel (a required property) was received
	if !channelReceived {
		return errors.New("\"channel\" is required but was not present")
	}
	// check if expiration-date (a required property) was received
	if !expirationDateReceived {
		return errors.New("\"expiration-date\" is required but was not present")
	}
	// check if progressive (a required property) was received
	if !progressiveReceived {
		return errors.New("\"progressive\" is required but was not present")
	}
	// check if revision (a required property) was received
	if !revisionReceived {
		return errors.New("\"revision\" is required but was not present")
	}
	return nil
}

func (strct *ChannelsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Branch" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "branch" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"branch\": ")
	if tmp, err := json.Marshal(strct.Branch); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Fallback" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "fallback" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"fallback\": ")
	if tmp, err := json.Marshal(strct.Fallback); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Risk" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "risk" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"risk\": ")
	if tmp, err := json.Marshal(strct.Risk); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Track" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "track" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"track\": ")
	if tmp, err := json.Marshal(strct.Track); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ChannelsItems) UnmarshalJSON(b []byte) error {
	branchReceived := false
	fallbackReceived := false
	nameReceived := false
	riskReceived := false
	trackReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "branch":
			if err := json.Unmarshal([]byte(v), &strct.Branch); err != nil {
				return err
			}
			branchReceived = true
		case "fallback":
			if err := json.Unmarshal([]byte(v), &strct.Fallback); err != nil {
				return err
			}
			fallbackReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		case "risk":
			if err := json.Unmarshal([]byte(v), &strct.Risk); err != nil {
				return err
			}
			riskReceived = true
		case "track":
			if err := json.Unmarshal([]byte(v), &strct.Track); err != nil {
				return err
			}
			trackReceived = true
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	// check if branch (a required property) was received
	if !branchReceived {
		return errors.New("\"branch\" is required but was not present")
	}
	// check if fallback (a required property) was received
	if !fallbackReceived {
		return errors.New("\"fallback\" is required but was not present")
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	// check if risk (a required property) was received
	if !riskReceived {
		return errors.New("\"risk\" is required but was not present")
	}
	// check if track (a required property) was received
	if !trackReceived {
		return errors.New("\"track\" is required but was not present")
	}
	return nil
}

func (strct *Epoch) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Read" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "read" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"read\": ")
	if tmp, err := json.Marshal(strct.Read); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Write" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "write" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"write\": ")
	if tmp, err := json.Marshal(strct.Write); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Epoch) UnmarshalJSON(b []byte) error {
	readReceived := false
	writeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "read":
			if err := json.Unmarshal([]byte(v), &strct.Read); err != nil {
				return err
			}
			readReceived = true
		case "write":
			if err := json.Unmarshal([]byte(v), &strct.Write); err != nil {
				return err
			}
			writeReceived = true
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	// check if read (a required property) was received
	if !readReceived {
		return errors.New("\"read\" is required but was not present")
	}
	// check if write (a required property) was received
	if !writeReceived {
		return errors.New("\"write\" is required but was not present")
	}
	return nil
}

func (strct *Progressive) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "CurrentPercentage" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "current-percentage" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"current-percentage\": ")
	if tmp, err := json.Marshal(strct.CurrentPercentage); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Paused" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "paused" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"paused\": ")
	if tmp, err := json.Marshal(strct.Paused); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Percentage" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "percentage" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"percentage\": ")
	if tmp, err := json.Marshal(strct.Percentage); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Progressive) UnmarshalJSON(b []byte) error {
	currentPercentageReceived := false
	pausedReceived := false
	percentageReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "current-percentage":
			if err := json.Unmarshal([]byte(v), &strct.CurrentPercentage); err != nil {
				return err
			}
			currentPercentageReceived = true
		case "paused":
			if err := json.Unmarshal([]byte(v), &strct.Paused); err != nil {
				return err
			}
			pausedReceived = true
		case "percentage":
			if err := json.Unmarshal([]byte(v), &strct.Percentage); err != nil {
				return err
			}
			percentageReceived = true
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	// check if current-percentage (a required property) was received
	if !currentPercentageReceived {
		return errors.New("\"current-percentage\" is required but was not present")
	}
	// check if paused (a required property) was received
	if !pausedReceived {
		return errors.New("\"paused\" is required but was not present")
	}
	// check if percentage (a required property) was received
	if !percentageReceived {
		return errors.New("\"percentage\" is required but was not present")
	}
	return nil
}

func (strct *RevisionsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Architectures" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "architectures" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"architectures\": ")
	if tmp, err := json.Marshal(strct.Architectures); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "attributes" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"attributes\": ")
	if tmp, err := json.Marshal(strct.Attributes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "base" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"base\": ")
	if tmp, err := json.Marshal(strct.Base); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "build-url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"build-url\": ")
	if tmp, err := json.Marshal(strct.BuildUrl); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "confinement" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"confinement\": ")
	if tmp, err := json.Marshal(strct.Confinement); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "created-at" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"created-at\": ")
	if tmp, err := json.Marshal(strct.CreatedAt); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "epoch" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"epoch\": ")
	if tmp, err := json.Marshal(strct.Epoch); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "grade" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"grade\": ")
	if tmp, err := json.Marshal(strct.Grade); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Revision" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "revision" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"revision\": ")
	if tmp, err := json.Marshal(strct.Revision); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "sha3-384" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"sha3-384\": ")
	if tmp, err := json.Marshal(strct.Sha3384); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "size" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"size\": ")
	if tmp, err := json.Marshal(strct.Size); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Version" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "version" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RevisionsItems) UnmarshalJSON(b []byte) error {
	architecturesReceived := false
	revisionReceived := false
	versionReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "architectures":
			if err := json.Unmarshal([]byte(v), &strct.Architectures); err != nil {
				return err
			}
			architecturesReceived = true
		case "attributes":
			if err := json.Unmarshal([]byte(v), &strct.Attributes); err != nil {
				return err
			}
		case "base":
			if err := json.Unmarshal([]byte(v), &strct.Base); err != nil {
				return err
			}
		case "build-url":
			if err := json.Unmarshal([]byte(v), &strct.BuildUrl); err != nil {
				return err
			}
		case "confinement":
			if err := json.Unmarshal([]byte(v), &strct.Confinement); err != nil {
				return err
			}
		case "created-at":
			if err := json.Unmarshal([]byte(v), &strct.CreatedAt); err != nil {
				return err
			}
		case "epoch":
			if err := json.Unmarshal([]byte(v), &strct.Epoch); err != nil {
				return err
			}
		case "grade":
			if err := json.Unmarshal([]byte(v), &strct.Grade); err != nil {
				return err
			}
		case "revision":
			if err := json.Unmarshal([]byte(v), &strct.Revision); err != nil {
				return err
			}
			revisionReceived = true
		case "sha3-384":
			if err := json.Unmarshal([]byte(v), &strct.Sha3384); err != nil {
				return err
			}
		case "size":
			if err := json.Unmarshal([]byte(v), &strct.Size); err != nil {
				return err
			}
		case "version":
			if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
				return err
			}
			versionReceived = true
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	// check if architectures (a required property) was received
	if !architecturesReceived {
		return errors.New("\"architectures\" is required but was not present")
	}
	// check if revision (a required property) was received
	if !revisionReceived {
		return errors.New("\"revision\" is required but was not present")
	}
	// check if version (a required property) was received
	if !versionReceived {
		return errors.New("\"version\" is required but was not present")
	}
	return nil
}

func (strct *Root) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "ChannelMap" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "channel-map" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"channel-map\": ")
	if tmp, err := json.Marshal(strct.ChannelMap); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Revisions" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "revisions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"revisions\": ")
	if tmp, err := json.Marshal(strct.Revisions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Snap" field is required
	if strct.Snap == nil {
		return nil, errors.New("snap is a required field")
	}
	// Marshal the "snap" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"snap\": ")
	if tmp, err := json.Marshal(strct.Snap); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Root) UnmarshalJSON(b []byte) error {
	channelMapReceived := false
	revisionsReceived := false
	snapReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "channel-map":
			if err := json.Unmarshal([]byte(v), &strct.ChannelMap); err != nil {
				return err
			}
			channelMapReceived = true
		case "revisions":
			if err := json.Unmarshal([]byte(v), &strct.Revisions); err != nil {
				return err
			}
			revisionsReceived = true
		case "snap":
			if err := json.Unmarshal([]byte(v), &strct.Snap); err != nil {
				return err
			}
			snapReceived = true
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	// check if channel-map (a required property) was received
	if !channelMapReceived {
		return errors.New("\"channel-map\" is required but was not present")
	}
	// check if revisions (a required property) was received
	if !revisionsReceived {
		return errors.New("\"revisions\" is required but was not present")
	}
	// check if snap (a required property) was received
	if !snapReceived {
		return errors.New("\"snap\" is required but was not present")
	}
	return nil
}

func (strct *Snap) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Channels" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "channels" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"channels\": ")
	if tmp, err := json.Marshal(strct.Channels); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "default-track" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"default-track\": ")
	if tmp, err := json.Marshal(strct.DefaultTrack); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "id" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "private" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"private\": ")
	if tmp, err := json.Marshal(strct.Private); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "publisher" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"publisher\": ")
	if tmp, err := json.Marshal(strct.Publisher); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "title" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "tracks" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"tracks\": ")
	if tmp, err := json.Marshal(strct.Tracks); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Snap) UnmarshalJSON(b []byte) error {
	channelsReceived := false
	nameReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "channels":
			if err := json.Unmarshal([]byte(v), &strct.Channels); err != nil {
				return err
			}
			channelsReceived = true
		case "default-track":
			if err := json.Unmarshal([]byte(v), &strct.DefaultTrack); err != nil {
				return err
			}
		case "id":
			if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		case "private":
			if err := json.Unmarshal([]byte(v), &strct.Private); err != nil {
				return err
			}
		case "publisher":
			if err := json.Unmarshal([]byte(v), &strct.Publisher); err != nil {
				return err
			}
		case "title":
			if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
				return err
			}
		case "tracks":
			if err := json.Unmarshal([]byte(v), &strct.Tracks); err != nil {
				return err
			}
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	// check if channels (a required property) was received
	if !channelsReceived {
		return errors.New("\"channels\" is required but was not present")
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	return nil
}

func (strct *TracksItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "CreationDate" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "creation-date" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"creation-date\": ")
	if tmp, err := json.Marshal(strct.CreationDate); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "status" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "version-pattern" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"version-pattern\": ")
	if tmp, err := json.Marshal(strct.VersionPattern); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TracksItems) UnmarshalJSON(b []byte) error {
	createdDateReceived := false
	nameReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "creation-date":
			if err := json.Unmarshal([]byte(v), &strct.CreationDate); err != nil {
				return err
			}
			createdDateReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		case "status":
			if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
				return err
			}
		case "version-pattern":
			if err := json.Unmarshal([]byte(v), &strct.VersionPattern); err != nil {
				return err
			}
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	// check if creation-date (a required property) was received
	if !createdDateReceived {
		return errors.New("\"creation-date\" is required but was not present")
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	return nil
}
